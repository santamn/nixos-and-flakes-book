# よくある質問

# よくある質問 FAQ

## NixOS のロールバック能力と btrfs / zfs システム快照回滚有何不同？

多くの Arch Linux / Ubuntu などの通常の Linux ディストリビューションのユーザーは、btrfs / zfs などのファイルシステムが提供するスナップショットを「後悔薬」として使用することに慣れており、システムに問題が発生した場合にロールバックして修復できます。本書で紹介する NixOS もシステム状態のロールバック機能を提供しているため、これら2つのシステムロールバック機能の違いについて疑問が生じやすいです。

ここで簡単に説明すると、主な違いは、スナップショットの内容にはゼロからこのスナップショットを構築する方法の「知識」が含まれておらず、**解釈不可能**であり、その内容は現在のハードウェア環境に強く関連しているため、他のマシンで再現することが困難であるという点です。

一方、NixOS の設定は、ゼロからまったく同じ OS を構築するための「知識」であり、**解釈可能**であり、簡単な数行のコマンドでこの構築を自動的に完了できます。NixOS の設定自体は、NixOS システムで行われた変更を記録するドキュメントであり、現在の NixOS システムを自動的に構築するために直接使用することもできます。

NixOS の設定ファイルは、プログラムの**ソースコード**のようなものです。ソースコードが失われない限り、プログラムの変更、レビュー、またはまったく同じプログラムの再構築は非常に簡単です。一方、システムスナップショットは、ソースコードからコンパイルされたバイナリプログラムのようなものであり、変更やレビューははるかに困難です。また、このスナップショットは非常に大きく、共有または移行のコストはソースコードよりもはるかに高くなります。

しかし、これは NixOS があればシステムスナップショットが不要になるという意味ではありません。本書の第1章で紹介したように、NixOS は宣言的設定で宣言されたすべての内容が再現可能であることを保証するだけであり、宣言的設定でカバーされていない他のシステム状態は管轄外です。たとえば、MySQL/PostgreSQL の動的データ、ユーザーがアップロードしたファイル、システムログなど、ユーザーのホームディレクトリにあるビデオ、音楽、写真などは、依然としてファイルシステムのスナップショットやその他の手段でバックアップする必要があります。

## Nix と Ansible などの従来のシステム運用ツールと比較して、長所と短所は何ですか？

Nix はデスクトップコンピュータの環境管理だけでなく、クラウドサーバーのバッチ管理にも多くの人が使用しており、Nix 公式の [NixOps](https://github.com/NixOS/nixops) とコミュニティの [colmena](https://github.com/zhaofengli/colmena) は、このシナリオのために特別に開発されたツールです。

Nix が Ansible のような広く使用されている従来のツールと比較して主な利点は次のとおりです。

1. Ansible のようなツールの最大の問題の1つは、各デプロイがシステムの現在の状態に対する増分変更であることです。システムの現在の状態は、前述のシステムスナップショットと同様に、解釈不可能であり、再現が困難です。一方、NixOS は設定ファイルを通じてシステムの目標状態を宣言するため、デプロイ結果はシステムの現在の状態とは無関係であり、繰り返しデプロイしても問題は発生しません。
2. Nix Flakes は、バージョンロックファイル `flake.lock` を通じて、すべての依存関係のハッシュ値、バージョン番号、データソースなどの情報をロックし、システムの再現性を大幅に向上させます。一方、従来の Ansible などのツールにはこの機能がないため、再現性が非常に低いです。
   1. これが Docker がこれほど人気がある理由の1つです。Docker は、Ansible などの従来の運用ツールが提供できない**さまざまなマシンで再現可能なシステム環境**を低コストで提供します。
3. Nix は、宣言的な抽象化の層を通じて、その基盤となる実装の詳細を隠蔽し、ユーザーが最も中心的な要件にのみ集中できるようにすることで、非常に便利なシステムカスタマイズ機能を提供します。一方、Ansible のようなツールの抽象化能力ははるかに弱いです。
   1. terraform/kubernetes などの宣言的設定ツールを使用したことがある場合は、この点を簡単に理解できるはずです。要件が複雑になるほど、宣言的設定がもたらす利点は大きくなります。

## Nix と Docker コンテナ技術と比較して、どのような利点がありますか？

Nix と Docker に代表されるコンテナ技術の応用シーンには、ある程度の重複があります。例えば：

1. 多くの人が Nix を使って開発・コンパイル環境を管理しており、本書でも紹介しています。しかし、一方で [Dev Containers](https://github.com/devcontainers/spec) のようなコンテナベースで開発環境を構築する技術も非常に人気があります。
2. 現在、DevOps/SRE 分野全体が基本的に Dockerfile ベースのコンテナ技術の世界であり、コンテナでは Ubuntu/Debian などのディストリビューションがよく使われ、ホストマシンにも多くの成熟したディストリビューションの選択肢があります。NixOS に切り替えることに何か明らかな利点はありますか？

そのうちの第一点「開発・コンパイル環境の管理」について、Nix が作成する開発環境の体験は、ホストマシンで直接開発するのに非常に近く、Dev Containers よりもはるかに優れています。例を挙げます：

1. Nix は名前空間を使用してファイルシステムやネットワーク環境などを隔離しないため、Nix が作成した開発環境では、ホストマシンのファイルシステム（/dev ホストマシンの外部デバイスを含む）やネットワーク環境などと簡単にやり取りできます。一方、コンテナはさまざまなマッピングを介してホストマシンのファイルシステムと通信する必要があり、それでもファイル権限の問題が発生する可能性があります。
2. 強力な隔離を行っていないため、Nix 開発環境は GUI プログラムのサポートにも何の問題もありません。この環境で GUI プログラムを実行する体験は、システム環境で GUI プログラムを実行するのと何ら変わりありません。

つまり、Nix はホストマシンに最も近い開発体験を提供でき、強力な隔離はなく、開発者はこの環境でさまざまな使い慣れた開発・デバッグツールを使用でき、過去の開発経験のほとんどを問題なく移行できます。一方、Dev Containers を使用する場合、開発者は強力な隔離によるさまざまなファイルシステムの非互換性、ネットワーク環境の問題、ユーザー権限の問題、GUI デバッグツールが使用できないなどのさまざまな問題に遭遇する可能性があります。

そして、すべての開発環境を Nix で管理することに決めた場合、Docker コンテナを構築する際にも Nix をベースに構築すれば、明らかに最強の一貫性を提供でき、同時にすべての環境の技術アーキテクチャが統一されるため、インフラ全体のメンテナンスコストも大幅に削減できます。これは、前述の第二点、Nix を使用して開発環境を管理することを前提として、コンテナのベースイメージとクラウドサーバーの両方に NixOS を使用することに明らかな利点があることを示しています。

## error: collision between `...` and `...`

このエラーは、同じプロファイルに、同じライブラリに依存するがバージョンが異なる2つのパッケージをインストールしようとすると発生します。

たとえば、次のような設定があるとします。

```nix
{
   # nixos moduleとして
   # environment.systemPackages = with pkgs; [
   #
   # またはhome manager moduleとして
   home.packages = with pkgs; [
     lldb

     (python311.withPackages (ps:
       with ps; [
         ipython
         pandas
         requests
         pyquery
         pyyaml
       ]
     ))
   ];
}
```

この設定をデプロイすると、次のエラーが発生します。

```bash
error: builder for '/nix/store/n3scj3s7v9jsb6y3v0fhndw35a9hdbs6-home-manager-path.drv' failed with exit code 25;
       last 1 log lines:
       > error: collision between `/nix/store/kvq0gvz6jwggarrcn9a8ramsfhyh1h9d-lldb-14.0.6/lib/python3.11/site-packages/six.py'
and `/nix/store/370s8inz4fc9k9lqk4qzj5vyr60q166w-python3-3.11.6-env/lib/python3.11/site-packages/six.py'
       For full logs, run 'nix log /nix/store/n3scj3s7v9jsb6y3v0fhndw35a9hdbs6-home-manager-path.drv'.
```

解決策は次のとおりです。

1. 2つのパッケージを2つの異なる **profiles** に分割します。たとえば、`environment.systemPackages` を介して `lldb` をインストールし、`home.packages` を介して `python311` をインストールできます。
2. 異なるバージョンの Python3 は異なるパッケージと見なされるため、カスタム Python3 のバージョンを `python310` に変更して競合を回避できます。
3. `override` を使用して、パッケージが使用するライブラリのバージョンを、他のパッケージが使用するバージョンと一致するように上書きします。

```nix
{
  # nixos moduleとして
  # environment.systemPackages = with pkgs; [
  #
  # またはhome manager moduleとして
  home.packages = let
    custom-python3 = (pkgs.python311.withPackages (ps:
      with ps; [
        ipython
        pandas
        requests
        pyquery
        pyyaml
      ]
    ));
  in
    with pkgs; [
      # python3のバージョンを上書き
      # 注：これによりlldbが再ビルドされ、時間がかかります
      (lldb.override {
        python3 = custom-python3;
      })

      custom-python3
  ];
}
```

## Nixは、Ansibleなどの従来のシステム管理ツールとどのように比較されますか？

Nixはデスクトップ環境の管理だけでなく、クラウドサーバーのバッチ管理にも広く使用されています。NixOSコミュニティからの公式[NixOps](https://github.com/NixOS/nixops)とコミュニティによって開発された[colmena](https://github.com/zhaofengli/colmena)は、この使用ケースのために特別に設計されたツールです。

広く使用されているAnsibleなどの従来のツールと比較すると、Nixには以下の主な利点があります：

1. Ansibleの最大の問題の一つは、各デプロイメントがシステムの現在の状態への増分変更に基づいていることです。上記で言及されたスナップショットと同様に、システムの現在の状態は解釈不可能であり、再現が困難です。NixOSは設定ファイルを通じてシステムの目標状態を宣言するため、デプロイメント結果はシステムの現在の状態から独立しており、繰り返しデプロイメントが問題を引き起こすことはありません。
2. Nix Flakesはバージョンロックファイル`flake.lock`を使用して、すべての依存関係のハッシュ値、バージョン番号、データソース、その他の情報をロックし、システムの再現性を大幅に向上させます。Ansibleなどの従来のツールにはこの機能がないため、あまり再現性がありません。
   1. これがDockerが非常に人気である理由です - それは従来のAnsibleなどのOpsツールにはない、**幅広いマシンで再現可能なシステム環境**をわずかなコストで提供します。
3. Nixは、基礎的な実装詳細を宣言的抽象化の層で遮蔽することにより、高度なシステムカスタマイゼーションの容易さを提供し、ユーザーは自分のコア要件にのみ注意を払えばよくなります。Ansibleなどのツールはより弱い抽象化を持っています。
   1. terraform/kubernetesなどの宣言的設定ツールを使用したことがある場合、これは理解しやすいはずです。要件が複雑になるほど、宣言的設定の利点が大きくなります。

## Nixは、Dockerコンテナ技術と比較してどのような利点がありますか？

NixとDockerなどのコンテナ技術には確かに重複する使用ケースがあります。例えば：

1. 多くの人がこの本で議論されているように、開発およびビルド環境を管理するためにNixを使用しています。一方で、コンテナベースの開発環境を構築する[Dev Containers](https://github.com/devcontainers/spec)などの技術も人気があります。
2. DevOps/SRE分野は現在、Dockerfileベースのコンテナ技術によって支配されています。Ubuntu/Debianなどの一般的に使用されるディストリビューションは、コンテナ内で頻繁に使用され、ホストマシン用の成熟したオプションも利用可能です。この文脈で、NixOSへの切り替えはどのような重要な利点を提供するのでしょうか？

「開発およびビルド環境の管理」の最初の点に関して、Nixはホストマシンで直接作業することに非常に似た開発環境体験を提供します。これはDev Containersに対していくつかの利点を提供します。以下に概説します：

1. Nixはファイルシステムとネットワーク分離のために名前空間を使用しないため、Nixが作成した開発環境内でホストマシンのファイルシステム（外部デバイス用の/devを含む）とネットワーク環境との簡単な相互作用が可能です。対照的に、コンテナはコンテナとホストマシンのファイルシステム間の通信を可能にするために様々なマッピングを必要とし、時にはファイル権限の問題を引き起こす可能性があります。
2. 強力な分離がないため、Nix開発環境はGUIアプリケーションのサポートに問題がありません。この環境内でGUIプログラムを実行することは、システム環境で実行することと同じくらいシームレスです。

言い換えれば、Nixは強力な分離なしに、ホストマシンに最も近い開発体験を提供します。開発者はこの環境で慣れ親しんだ開発およびデバッグツールを使用でき、過去の開発経験をシームレスに移行できます。一方、Dev Containersを使用する場合、開発者は強力な分離のため、ファイルシステム通信、ネットワーク環境、ユーザー権限、GUIデバッグツールの使用不能に関連する様々な問題に遭遇する可能性があります。

すべての開発環境をNixで管理することを決定した場合、NixベースのDockerコンテナの構築は最高レベルの一貫性を提供します。さらに、すべての環境に統一された技術アーキテクチャを採用することで、インフラストラクチャの保守コストが大幅に削減されます。これは前述の2番目の点に答えます：Nixで開発環境を管理することを前提とする場合、コンテナベースイメージとクラウドサーバーにNixOSを使用することは明確な利点を提供します。

## error: collision between `...` and `...`

このエラーは、同じプロファイル（ホームモジュールまたはnixosモジュール）内で、同じライブラリに依存するが異なるバージョンを持つ2つのパッケージをインストールした場合に発生します。

例えば、以下の設定がある場合：

```nix
{
   # nixosモジュールとして
   # environment.systemPackages = with pkgs; [
   #
   # またはhome managerモジュールとして
   home.packages = with pkgs; [
     lldb

     (python311.withPackages (ps:
       with ps; [
         ipython
         pandas
         requests
         pyquery
         pyyaml
       ]
     ))
   ];
}
```

これにより以下のエラーが発生します：

```bash
error: builder for '/nix/store/n3scj3s7v9jsb6y3v0fhndw35a9hdbs6-home-manager-path.drv' failed with exit code 25;
       last 1 log lines:
       > error: collision between `/nix/store/kvq0gvz6jwggarrcn9a8ramsfhyh1h9d-lldb-14.0.6/lib/python3.11/site-packages/six.py'
and `/nix/store/370s8inz4fc9k9lqk4qzj5vyr60q166w-python3-3.11.6-env/lib/python3.11/site-packages/six.py'
       For full logs, run 'nix log /nix/store/n3scj3s7v9jsb6y3v0fhndw35a9hdbs6-home-manager-path.drv'.
```

以下はいくつかの解決策です：

1. 2つのパッケージを2つの異なる**プロファイル**に分割します。例えば、`lldb`を`environment.systemPackages`経由でインストールし、`python311`を`home.packages`経由でインストールできます。
2. Python3の異なるバージョンは異なるパッケージとして扱われるため、競合を回避するためにカスタムPython3バージョンを`python310`に変更できます。
3. `override`を使用して、パッケージが使用するライブラリのバージョンを他のパッケージが使用するバージョンと一致するようにオーバーライドします。

```nix
{
  # nixosモジュールとして
  # environment.systemPackages = with pkgs; [
  #
  # またはhome managerモジュールとして
  home.packages = let
    custom-python3 = (pkgs.python311.withPackages (ps:
      with ps; [
        ipython
        pandas
        requests
        pyquery
        pyyaml
      ]
    ));
  in
    with pkgs; [
      # python3のバージョンをオーバーライド
      # 注意：これはlldbの再ビルドをトリガーし、時間がかかります
      (lldb.override {
        python3 = custom-python3;
      })

      custom-python3
  ];
}
```
